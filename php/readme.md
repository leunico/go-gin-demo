# 知识点

> ## 网络篇

### 七层协议
- 应用层 各种应用程序协议，如HTTP、FTP、SMTP、POP3等一些传输协议。
- 表示层 信息的语法语义以及他们的关联，如加密解密、转换翻译等。
- 会话层 不同机器上的用户之间建立及管理会话，如SSL、TLS、RPC等。
- 传输层 接受上一层的数据，在必要的时候把数据进行分割，并将这些数据交给网络层。如TCP、UDP协议
- 网络层 就是IP/IPV6
- 数据链路层 物理寻址。跟网卡驱动有关
- 物理层 硬件

### UDP的特点
- 它是无连接的，即发送数据之前不需要建立连接（发送数据结束时也没有连接可以释放），减少了开销和发送数据之前的时间延迟
- 使用尽最大努力交付数据，即不保证可靠交付，主机不需要维持复杂的连接状态表
- 支持一对一、一对多、多对一的交互通信
- 首部开销小，只有8个字节，比Tcp的20字节的首部要短

### TCP的三次握手
- 第一次客户端发送SYN=1,ack=0,seq=x给服务器
- 第二次服务器发送SYN=1,ACK=1,seq=y,ack=x+1给客户端
- 第三次客户端发送ACK=1,seq=x+1,ack=y+1给服务器

### TCP的四次分手
- 第一次客户端发送FIN=1,seq=u给服务器
- 第二次服务器发送ACK=1,seq=v,ack=u+1给客户端
- 第三次服务端发送FIN=1,seq=w,ack=u+1给客户端
- 第四次客户端发送ACK=1,seq=u+1,ack=w+1给服务器

### 建立Socket需要那些步骤
- 创建socket
- 绑定socket到指定地址和端口
- 开始监听连接
- 读取客户端输入
- 关闭socket

> ## 关于IO的一些枯燥理论

### 同步IO
- 阻塞IO
- 非阻塞IO
- IO多路复用 （select poll epoll）
- 信号驱动

### 同步异步，阻塞非阻塞
- 你去甜在心馒头店买太极馒头，阿梅说：＂暂时没，正在蒸呢，你自己看着点儿！＂．于是你就站在旁边只等馒头．此时的你，`是阻塞的，是同步的`．阻塞表现在你除了等馒头，别的什么都不做了．同步表现在等馒头的过程中，阿梅不提供通知服务，你不得不自己要等到＂馒头出炉＂的消息.
- 你去甜在心馒头店买太极馒头，阿梅说：＂暂时没，正在蒸呢，你自己看着点儿！＂．于是你就站在旁边发微信，然后问一句：＂好了没？＂，然后发QQ，然后再问一句：＂好了没？＂．此时的你，`是非阻塞的，是同步的`．非阻塞表现在你除了等馒头，自己还干干别的时不时会主动问问馒头好没好．同步表现在等馒头的过程中，阿梅不提供通知服务，你不得不自己要等到＂馒头出炉＂的消息．
- 你去甜在心馒头店买太极馒头，阿梅说：＂暂时没，正在蒸呢，蒸好了我打电话告诉你！＂．但你依然站在旁边只等馒头，此时的你，`是阻塞的，是异步的`．阻塞表现在你除了等馒头，别的什么都不做了．异步表现在等馒头的过程中，阿梅提供电话通知＂馒头出炉＂的消息，你只需要等阿梅的电话．
- 你去甜在心馒头店买太极馒头，阿梅说：＂暂时没，正在蒸呢，蒸好了我打电话告诉你！＂．于是你就走了，去买了双新球鞋，看了看武馆，总之，从此不再过问馒头的事情，一心只等阿梅电话．此时的你，`是非阻塞的，是异步的`．非阻塞表现在你除了等馒头，自己还干干别的时不时会主动问问馒头好没好．异步表现在等馒头的过程中，阿梅提供电话通知＂馒头出炉＂的消息，你只需要等阿梅的电话．

阻塞和非阻塞关注的是：在等馒头的过程中，你在干啥．
同步和异步关注的是：等馒头这件事，你是一直等到＂馒头出炉＂的结果，还是立即跑路等阿梅告诉你的＂馒头出炉＂．重点的是你是如何得知＂馒头出炉＂的。

所以现实世界中，最傻的人才会采用异步阻塞的IO方式去写程序．其余三种方式，更多的人都会选择同步阻塞或者异步非阻塞．同步非阻塞最大的问题在于，你需要不断在各个任务中忙碌着，导致你的大脑混乱，非常累．

> ## 负载均衡

类型|优点|缺点|适用场景
:-:|:-:|:-:|:-:
顺序轮询|静态、稳定|不关心服务器负载，服务器处理能力波动可能堵塞|服务器处理能力高且稳定
加权轮询|静态、稳定，允许服务器端性能差异|不关心服务器负载，服务器处理能力波动可能堵塞|服务器处理能力高且稳定
最少连接|动态、实时变化|复杂度提升，每次开关连接时需要计数|服务器处理能力有波动
最快响应|动态、实时变化，支持到请求级别比最少连接更灵敏|复杂度提升，需要计算请求的响应时间|服务器处理能力有波动
Hash算法|算法稳定|有客户端决定分布，可能导致分布不均匀|同一个客户端和服务端需要反复通信

> ## Mysql数据库的锁

### 聚集索引 - 辅助索引
- Myisam引擎，使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址，此索引方式也叫做非聚集的。
- Innodb引擎，他的数据文件本身就是索引文件，表数据本身就是按照B+Tre组织的一个索引结构，这棵树的叶子结点data域保存了完整的数据记录，这个索引是主键，所以表文件本身就是主索引。聚集索引按住建搜索十分高效，但是辅助索引搜索需要两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中获得记录。

### 数据库锁的分类
- 表级锁：开销小，加锁快；不会出现死锁；锁定的粒度大，发生锁冲突的概率最高，并发度最低。

    其中包括读锁和写锁，读锁一般可查询不可写入，写锁两种皆不可以。
- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高，只会在Innodb中。
- 页级锁：开销和加锁时间介于上面两种之间；会出现死锁；锁定粒度介于上面之间，并发一般，一般在BDB引擎。

### 行锁
- 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
- 排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务获得相同数据集的共享读锁和排他锁。

另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁，这两种也是表锁。

### 表锁
- 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
- 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。
- 自增锁：特殊表锁，自增长计数器通过该锁来获得子增长计数器最大计数值。

在加行级锁之前必须先获得表级意向锁，否则等待innodb_lock_wait_timeout超时后根据innodb_rollback_on_timeout决定是否回滚事务。

在innodb引擎里面我们设计表结构的时候，通常会建议添加一列作为自增主键。这里就涉及到一个特殊的锁：自增锁，它属于表锁的一种，在添加数据结束后立即释放。

### 锁的矩阵关系（”+“表示兼容，“-”表示不兼容）
\\|意向共享锁（IS）|意向排他锁（IX）|自增锁|共享锁|排他锁
:-:|:-:|:-:|:-:|:-:|:-:
意向共享锁（IS）|+|+|+|+|-
意向排他锁（IX）|+|+|+|-|-
自增锁|+|+|-|-|-
共享锁|+|-|-|-|-
排他锁|-|-|-|-|-

InnoDB行锁是通过对索引数据页上的记录加锁实现的。

1. record lock锁：单个记录的锁（锁数据，不锁Gap）
2. gap lock锁：间隙锁，锁住一个范围，不包括记录本身（不锁数据，仅仅锁数据前面的gap）
3. next-key lock锁同时锁住数据，并且锁住数据前面的Gap。所以就是上面两个相加。

排查InnoDB锁问题通常可以有两种方法：
1. 打开innodb_lock_monitor表，注意使用后记得关闭，会影响性能。
2. 在Mysql5.5之后，可以通过查看information_schema库下面的innodb_locks,innodb_locak_waits,innodb_trx三个视图。

### InnoDB不同索引的加锁行为
分析锁要跟隔离级别联系起来，我们以RR（可重复读）为例子，主要锁一下四种
- 主键+RR：修改行以主键为条件，仅在主键索引记录上加X锁
- 唯一键+RR：修改行以唯一索引为条件，先在唯一索引上加X锁，再在主键对应数据的主键索引上加X锁
- 非唯一键+RR：以普通索引为条件。先定位到记录位置加X锁，然后在位置前后加上gap lock即间隙锁，防止幻读，然后在主键索引上加上X锁。
如果有多个记录，需要依次这样操作。
- 无索引+RR：条件无索引，表里所有行加上next-key locak

### InnoDB死锁产生条件及避免优化
在Mysql中死锁不会发生在Myisam引擎中，但会在InnoDB中，因为他是逐行加锁，极易出现死锁。
#### 产生死锁的条件
1. 互斥条件：一个资源每次只能被一个进程使用；
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放；
3. 不剥夺条件：进程已获得资源，在没有使用完全之前，不能强行剥夺；
4. 循环等待条件：多个进程之间形成一种互相循环等待资源的关系。

在发生死锁的时候，引擎会自动检测，并且会自动回滚代价较小的事务来解决死锁。但很多时候一旦发生死锁，引擎的处理效率是很地下或者解决不了的，需要人为手工取解决。

#### 避免死锁的建议
1. 加锁顺序一致
2. 尽量基于primary或unique key更新数据
3. 单次操作数据量不宜过多，涉及的表尽量少
4. 减少表上索引，减少锁定资源 // todo ？？？
5. 更新SQL的where条件尽量用索引
6. 加锁索引准确，缩小锁定范围
7. 减少范围更新，尤其非主键/非唯一索引上的范围更新
8. 控制事务大小，减少锁定数据量和锁定时间长度
9. 加锁顺序一致，尽可能一次性锁定所有所需数据行

> ## 数据库中间件

### 垂直拆分
通常来说，垂直拆分，都是根据业务来对一个库中的表进行拆分的。关于垂直拆分，还有另一种说法，将一个包含了很多字段的大表拆分为多个小表，每个表包含部分字段，这种情况在开发中很少遇到。// todo ？？？

垂直拆分的另一个典型应用是服务化改造，在服务化的背景下，除了业务上需要进行拆分，底层的存储也需要进行隔离。垂直拆分会使得单个用户的请求时间变长，原因在于，在单体应用的场景下，所有的业务都可以在一个节点内部完成，而垂直拆分之后，通常会需要进行RPC调用。然后虽然单个请求的响应时间增加了，但是整个服务的吞吐量确会大大的增加。

### 读写分离
#### 优点
通过配置多个SLAVE节点，可以有效的避免过大的访问量对单个库造成的压力。
#### 挑战
1. 多了很多集群运维工作
例如集群搭建、主从切换、从库扩容、缩容等。例如master配置了多个slave节点，如果其中一个slave节点挂了，那么之后的读请求，我们应用将其转发到正常工作的slave节点上。另外如果新增了slave节点，应用也应该感知到，可以将读请求转发到新的slave节点上。
2. 对于开发人员来说
- 基本读写分离功能
- 主从数据同步延迟问题（需提供一种方式，某些读请求也可以走主库）
- 事务问题（也是统一走一个库）
- 感知集群信息变更

### 分库分表
- 只分库
- 只分表
- 分库分表
#### 优点
如果说读写分离实现了数据库读能力的水平扩展，那么分库分表就是实现了写能力的水平扩展。
#### 挑战
1. 基本数据库的CURD操作
- SQL解析
- SQL路由（确认插入到那个库）
- SQL改写（实际操作的SQL语句）
- SQL执行（也许有多条语句执行）
2. 分布式ID

防止ID冲突，比如Twitter的雪花算法。

3. 分布式事务
- XA事务
- 柔性事务

4. 动态扩容

可利用一致性hash算法

> ## IO多路复用
- 当客户处理多个描述字时（一般时交互式输入和网络套接口）
- 如果一个服务器既要处理TCP，又要处理UDP，一般要使用I/O复用
- 如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口

1. select
- 每次调用select，都要把FD集合从用户态拷贝到内核态，这个开销在FD很多时会很大
- 同时每次调用select都需要在内核遍历传递进来的所有FD，这个开销在FD很多时也很大
- select支持的文件描述符也有限，只有1024/2048

如果文件描述符不够表现为

`Too many open files (24)`

2. poll

poll跟select差不多，不过可以支持的文件描述符不限（链表保存）

3. epoll
- epoll是线程安全的，而select和poll不是
- epoll内部使用了mmap共享了用户和内核部分空间，减少了数据来回拷贝
- epoll基于事件驱动，epoll_ctl注册事件并注册callback回调函数，epoll_wait只返回发生的事件避免了像select和poll对事件的轮询操作

#### 总结
1. select poll 实现需要自己不断的轮询所有的fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是他的设备就绪时，调用回调函数，把就绪FD放入就绪的链表中，并唤醒在epoll_wait中进入睡眠的进程，虽然都要睡眠和交替，但是select和poll在醒着的时候要遍历整个FD集合，而epoll在醒着的时候只要判断就绪链表是否为空就行，这节省了大量的CPU时间，带来性能的提升。
2. select poll每次调用都要把FD集合从用户态往内核态拷贝一次，并且current往设备等待队列中挂一次，而epoll只要拷贝一次。

> ## 基础啊！

### 进程、线程、协程
- 进程是一个程序在一个数据集中的一次动态执行过程，可以简单理解为“正在执行的程序”，它是CPU资源分配和调度的独立单位。
- 线程是在进程之后发展出来的概念，线程也叫轻量级进程，它是一个基本的CPU执行单元，也是程序执行过程中的最小单元，由线程ID、程序计数器、寄存器集合和堆栈共同组成，一个进程可以包含多个线程。
- 协程是一种用户态的轻量级线程，又称微线程，他的调度完全是由用户操作。
#### 通信方式
- 信号量
- 消息队列
- 共享内存
- 信号
- 管道
- 套接字

### PHP基础
- echo：输出一个或多个字符串，是结构语言
- print：输出字符串，是结构语言
- print_r：打印变量，是普通函数
- var_dump：打印变量，是普通函数
- isset：检测变量是否设置并且非null
- empty：判断变量是否为空，变量为0/false也会被认为空
- static：static可以用于静态或者非静态方法中，也可以访问类的静态属性、静态方法、常量和非静态方法，但不能访问非静态属性
    1. 静态方法不需要实例化即可调用，因为静态属性存放的位置是类里面，
    2. 静态方法不需要实例化即可调用
    3. 静态方法不能调用非静态属性，因为非静态属性需要实例化后存放在对象里面。
    4. 非静态方法可以调用静态方法，使用self关键字
    5. 调用类的静态函数时不会自动调用类的构造函数
- self：可以用于访问类的静态属性、静态方法和常量，但是self指的是当前类
- $this：指向的是实际调用时的对象，也就是说，实际运行过程中，谁调用了类的属性或者方法，$this就指向那个对象，但是$this不能访问类的静态属性和常量，且不存在于静态方法当中
- require和include几乎一样，只是处理失败方式不同，require会产生错误而中止程序，但是include只是产生警告，继续运行。
- trait：trait的方法会覆盖基类中的同名方法，而本类会覆盖trait中同名方法，属性不可以同名
- 客户端IP：$_SERVER['REMOTE_ADDR']/代理$_SERVER['HTTP_X_FORWARDED_FOR']

#### 类的静态调用和实例化调用
- 占用内存
    1. 静态方法在内存中只有一份，无论调用多少次，都是公用的
    2. 实例化不一样，每个实例化是一个对象，在内存中是多个的
- 不同点
    1. 静态调用不需要实例化即可调用
    2. 静态方法不能调用非静态属性，因为非静态属性需要实例化后，存放在对象里面
    3. 静态方法可以调用非静态方法，使用self关键字（低版本才可以）

#### 502和504
1. 502表示网关错误，当PHP-CGI得到一个无效响应，网关就会输出这个错误
    - 设置中memory_limit过小
    - php-fpm.conf中max_children、max_requests、request_terminate_timeout、max_execution_time设置不合理
2. 504表示网关超时，PHP-CGI没有在指定时间响应请求
    - nginx+php架构中，可以调整fastcgi超时时间来避免：fastcgi_connect_timeout,fastcgi_send_timeout,fastcgi_read_timeout等

#### MYSQL MYSQLI PDO
1. Mysql
    - 允许一个面向过程的接口
2. Mysqli
    - 面向对象接口
    - 多语句支持
    - 事务支持
    - 增强的调试能力
3. PDO
    - PHP应用中的一个数据库抽象层规范
    - PDO提供一个统一的API接口，无需关心数据库类型
    - 使用标准的PDO API，可以快速无缝切换数据库

#### PHP运行
PHP代码 =》 启动PHP以及ZEND引擎，加载注册拓展模块 =》 对代码进行词法/语法分析 =》 生成语法片断AST =》 编译成opcode =》 执行opcode

#### 发起HTTP请求方式
- curl
- file_get_contents
- fopen
- fsockopen

#### 垃圾回收机制
引用计数法，在5.3有优化

#### PHP7底层优化
- zval结构体优化，由占用24字节变成16字节
- 内部类型zend_string，结构体成员变量采用char数组
- 改进函数调用机制，优化参数传递机制，减少一些指令
- 改善数组结构，数组元素和hash映射表被分配在同一块内存里

#### 如何解决内存溢出
- 增大脚本处理的内存分配
- 变量引用后及时销毁
- 将数据分批处理

#### Redis、Memecached区别
- redis支持丰富的数据储存类型，string、hash、list、set和sorted set（zset）而memecache只支持简单的key-value结构
- memecache的key-value储存比redis采用hash结构来做key-value的内存利用率更高
- redis提供了事务功能，可以保证一系列命令的原子性
- redis支持数据持久化，可以将内存中的数据保存在磁盘中
- redis只使用单核，而memecache可以使用多核，所以平均每一个核上redis在存储小数据时效率更高

#### redis如何持久化
1. RDB持久化，将redis在内存中的状态保存到硬盘中，相当于备份数据库状态，就是磁盘快照
2. AOF持久化，AOF持久化是通过保存REDIS服务器锁执行的写状态来记录数据库的相当于备份数据库接受到的命令，所有被写入AOF的命令都是以REDIS的协议格式来保存的

### 重点：抽象类和接口
#### 接口
1. 接口不能定义成员变量，能定义常量
2. 子类必须实现接口定义的所有方法
3. 接口只能定义不能实现该方法
4. 接口没有构造函数
5. 接口中的方法都是默认public类型
#### 抽象类
1. 不能被实例化，可以定义子类必须实现的方法
2. 子类必须定义父类中所有的抽象方法，这些方法的访问控制必须跟父类一样，或者更宽松
3. 如果一个类中有一个抽象方法，则该类必须定义为抽象类
4. 抽象类可以有构造函数
5. 抽象类中的方法可以使用public之类的来修饰
#### 区别
1. 关键字不一样，一个锁implement，一个是extends，当然接口也可以用extends
2. 接口中不可以声明成员变量（包括静态变量），常量是可以的，但是抽象类可以
3. 接口没有构造函数，抽象类可以有
4. 接口中的方法默认都是public类型的，而抽象类中的方法可以使用修饰类型修饰public
5. 一个类可以有多个接口，但是一个类只能继承一个抽象类

如果要创建一个模型，这个模型将由一些紧密相关的对象采用，就可以使用抽象类，如果要创建不相关对象采用的功能，就使用接口。

### 算法基础
- 时间复杂度：执行算法需要的时间
- 空间复杂度：执行算法所需要的内存空间
#### 常见时间复杂度（效率从大到小）
1. 常数阶O(1)
2. 对数阶O(log2n)
3. 线性阶O(n)
4. nlog2n阶O(nlog2n)
5. 平方阶O(n^2)
6. 立方阶O(n^3)
7. 指数阶O(n^n)
#### 常见查找算法
1. 二分查找 时间复杂度对数阶O(log2n)，最坏平均都是这个
1. 顺序查找 时间复杂度对数阶O(n)，最坏平均都是这个
 
### GET和POST
- GET产生一个TCP数据包，而POST是两个
    GET是会把http header和data一起发送出去，服务器响应200
    POST是先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok



### 指针和引用
- 指针一般指的是某块内存的地址
- 引用指的是变量的别名

指针可以为空，引用不能为空

#### 内存泄露和内存溢出
- 内存泄露是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露不会有很大影响，但是内存泄漏堆积后就是内存溢出了
- 内存溢出是指申请内存时没有足够的内存够你使用

#### 定义和声明
区别就是定义会分配内存，声明只是告诉你某个类型的变量会被使用

#### 堆和栈
- 栈一般由系统自动分配，存放的是函数的参数值，局部变量的值等等。
- 堆是由程序员自己申请的，也就是各类的对象，程序会回收

#### 一致性哈希
- 如果新增加节点，能几乎保持一致

#### mysql主从复制
- 主服务器上面的修改通过I/O线程保存在二进制日志里面`Binary log`
- 从服务器上面也会启动一个I/O线程，通过配置好的用户名和密码，连接到主服务器上面请求读取二进制文件，同步到本地的一个中继日志里面`realy log`
- 从服务器上面同时开启一个SQL线程定时检查`realy log`，如果有改变就同步